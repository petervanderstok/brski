/* GM-server -- implementation of Group Manager using
 * a simple implementation of the Constrained Application Protocol (CoAP)
 *         as defined in RFC 7252
 * Group Manager (GM) server is added by:
 * Peter van der Stok <consultancy@vanderstok.org>
 * on request of Fairhair alliance
 * This file relies on oscore
 *
 * Copyright (C) 2010--2018 Olaf Bergmann <bergmann@tzi.org> and others
 *
 * This file is part of the CoAP library libcoap. Please see README for terms
 * of use.
 *
 * A resource exists for a group
 * A new group resource is created for a new group by authz-info
 */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#ifdef _WIN32
#define strcasecmp _stricmp
#include "getopt.c"
#if !defined(S_ISDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif
#else
#include <unistd.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <dirent.h>
#include <time.h>
#endif

#include "GM_server.h"
#include "coap_server.h"
#include "oscore.h"
#include "oscore-context.h"
#include "oscore_oauth.h"
#include "oscore-group.h"
#include "cbor.h"
#include "cose.h"
#include "coap_internal.h"

#ifdef __GNUC__
#define UNUSED_PARAM __attribute__ ((unused))
#else /* not a GCC */
#define UNUSED_PARAM
#endif /* GCC */

#define  NONCE_LEN  8
#define  SALT_LEN   24

unsigned char 
    public_key_C0[COSE_ALGORITHM_Ed25519_PUB_KEY_LEN] =
{0x01,  0x0a,  0x5b,  0xd2,  0x0a,  0xf0,  0xed,  0x21,  0x04,  0xcd,  0x23,  0x2f,  0x7f,  0x92,  0x8d,  0xda,  0x08,  0xc2,  0x79,  0xdc,  0x81,  0xf0,  0x56,  0x2b,  0x20,  0x14,  0xef,  0x71,  0x37,  0x46,  0x68,  0x71
};

unsigned char 
    public_key_C1[COSE_ALGORITHM_Ed25519_PUB_KEY_LEN] =
{0xae,  0xf1,  0x63,  0x00,  0xf6,  0x38,  0xec,  0x44,  0xd9,  0xf4,  0x47,  0x4f,  0x6d,  0xc0,  0xc4,  0xa4,  0x8b,  0x89,  0xb1,  0x4b,  0xe5,  0xef,  0xec,  0x09,  0xab,  0x18,  0x82,  0x57,  0x4e,  0xb0,  0x55,  0x26
};


unsigned char 
    public_key_C2[COSE_ALGORITHM_Ed25519_PUB_KEY_LEN] =
{0x29,  0x77,  0x86,  0x0a,  0x9a,  0xdb,  0xdd,  0xcf,  0x82,  0x11,  0xb1,  0xc9,  0x7f,  0xc2,  0x98,  0x44,  0xd8,  0x10,  0x5f,  0x96,  0x33,  0xdb,  0x82,  0x8a,  0xdf,  0xae,  0xba,  0x4c,  0x1e,  0x5f,  0xd1,  0xd2
};

unsigned char 
    private_key_C0[COSE_ALGORITHM_Ed25519_PRIV_KEY_LEN] =
{0x88,  0x91,  0x42,  0xbe,  0x02,  0x7e,  0x76,  0x30,  0xed,  0x6f,  0x1a,  0xb7,  0xd2,  0x90,  0xac,  0xd2,  0x43,  0x50,  0x30,  0x18,  0x39,  0x93,  0x99,  0x73,  0x83,  0x59,  0x14,  0xa9,  0x30,  0x13,  0x57,  0x7c,  0x4a,  0xc9,  0xcf,  0x74,  0x1a,  0x72,  0x47,  0x1a,  0xaf,  0x9e,  0xd0,  0x17,  0x44,  0x39,  0xf3,  0x9b,  0x97,  0xef,  0xc6,  0x3d,  0x0f,  0x86,  0xf2,  0x45,  0x4b,  0xe7,  0x54,  0xd1,  0xd9,  0xc8,  0x5e,  0x43
};

unsigned char
    private_key_C1[COSE_ALGORITHM_Ed25519_PRIV_KEY_LEN] =
{0xf0,  0xa1,  0x51,  0x21,  0xa5,  0x71,  0x92,  0x54,  0x6e,  0x67,  0x2d,  0x7e,  0x7a,  0x3f,  0xcb,  0x76,  0xd0,  0xbf,  0x2e,  0x03,  0xc9,  0x95,  0x41,  0x2e,  0x38,  0x56,  0x43,  0xba,  0x64,  0x31,  0xa5,  0x64,  0x9a,  0xd1,  0xcc,  0xf6,  0x25,  0x19,  0xe5,  0xc8,  0x9a,  0xff,  0x99,  0xaa,  0xad,  0xc2,  0x0d,  0xf8,  0xbc,  0x45,  0xef,  0xf3,  0x41,  0x02,  0x48,  0xfa,  0xb9,  0x51,  0xe6,  0x92,  0x78,  0x2d,  0x2b,  0x23
};

unsigned char 
   private_key_C2[COSE_ALGORITHM_Ed25519_PRIV_KEY_LEN] =
{0xf0,  0x76,  0xd2,  0xb1,  0x42,  0x33,  0xd0,  0x97,  0x94,  0x26,  0x60,  0x9d,  0x13,  0x1a,  0xe7,  0x43,  0xcc,  0xdd,  0x85,  0xbe,  0x21,  0xbc,  0xb3,  0x32,  0x1b,  0x9f,  0xb5,  0x7c,  0xca,  0x43,  0x84,  0x57,  0x27,  0x0d,  0x20,  0x29,  0xca,  0x59,  0xbb,  0x8d,  0xfc,  0x1c,  0xbe,  0x09,  0xc9,  0x21,  0x68,  0x02,  0x68,  0xc2,  0x12,  0x68,  0x01,  0xcd,  0x36,  0xd9,  0x7d,  0x40,  0xbd,  0x5c,  0xde,  0x9f,  0x04,  0x51
};

/* shared key between AS and GM */
static uint8_t ASGM_KEY[16] = {0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0x10};

/* kdcchallenge generated by server and combined with cnonce of join */
static uint8_t *kdcchallenge = NULL;

/* GM-create_context
 * creates context from information stored in token and salt
 */
void
GM_create_context(oauth_token_t *token, uint8_t *salt){
  
/* AD <-> GM
 * c1 <-> GM
 * c2 <-> GM
 * c0 <-> GM
 */
  oauth_cnf_t *pt = token->osc_sec_config;
  uint8_t *rid  = coap_malloc(pt->server_id_len);
  uint8_t *cid  = coap_malloc(pt->client_id_len);
  uint8_t *ctid = coap_malloc(pt->context_id_len);
  uint8_t *ms   = coap_malloc(pt->ms_len);
  uint8_t *loc_salt = coap_malloc(SALT_LEN);

  for (uint8_t qq =0; qq < pt->client_id_len; qq++) 
                     cid[qq] = pt->client_id[qq];
  for (uint8_t qq =0; qq < pt->server_id_len; qq++) 
                     rid[qq] = pt->server_id[qq];
  for (uint8_t qq =0; qq < pt->context_id_len; qq++) 
                     ctid[qq] = pt->context_id[qq];                 
  for (uint8_t qq =0; qq < pt->ms_len; qq++) 
                     ms[qq] = pt->ms[qq];
  for (uint8_t qq =0; qq < SALT_LEN; qq++) 
                     loc_salt[qq] = salt[qq];                  
  oscore_ctx_t *osc_ctx = oscore_derive_ctx(
    ms, pt->ms_len, loc_salt, SALT_LEN, 
    pt->alg,
    cid, pt->client_id_len, 
    rid, pt->server_id_len, 
    ctid, pt->context_id_len,
    OSCORE_DEFAULT_REPLAY_WINDOW);
  oscore_enter_context(osc_ctx);
}


/* GM_initial_conf
 * sets initial values in group configuration number 0
 * creates GRP_salt and GRP_master_secret
 */
static void
GM_initial_conf(oauth_cnf_t *cnf){/* master secret and salt for GRP <=> client contexts    */
  uint8_t GRP_salt[NONCE_LEN]; 
  uint8_t GRP_master_secret[COSE_algorithm_AES_CCM_16_64_128_KEY_LEN];
  prng(GRP_master_secret, COSE_algorithm_AES_CCM_16_64_128_KEY_LEN);
  prng(GRP_salt, NONCE_LEN);
  cnf->ms = coap_malloc(COSE_algorithm_AES_CCM_16_64_128_KEY_LEN);
  strncpy((char *)cnf->ms, (char *)GRP_master_secret, COSE_algorithm_AES_CCM_16_64_128_KEY_LEN);
  cnf->ms_len = COSE_algorithm_AES_CCM_16_64_128_KEY_LEN;
  cnf->salt = coap_malloc(NONCE_LEN);
  strncpy((char *)cnf->salt, (char *)GRP_salt, NONCE_LEN);
  cnf->salt_len = NONCE_LEN;
  cnf->server_id = NULL;
  cnf->server_id_len = 0;

/* the following values are updated in jr_to_ member  
 * for the join response Group_OSCORE_security_context_object
 */
  cnf->num = 0;
  cnf->client_id = NULL;
  cnf->client_id_len = 0;
}


/*
 * Return error and error message
 */
void
oscore_error_return(uint8_t error, coap_pdu_t *response,
                                       const char *message){
   unsigned char opt_buf[5];
  coap_log(LOG_WARNING,"%s",message);
  response->code = error;
  response->data = NULL;
  response->used_size = response->token_length;
  coap_add_option(response,
                COAP_OPTION_CONTENT_FORMAT,
                coap_encode_var_safe(opt_buf, sizeof(opt_buf),
                COAP_MEDIATYPE_TEXT_PLAIN), opt_buf);
  coap_add_data(response, strlen(message), 
                                  (const uint8_t *)message);
}


/* POST handler for group Member pub-key
 */
 static void
GM_hnd_post_member_pubkey(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}

/* PUT handler for group Member
 */
 static void
GM_hnd_put_member(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}


/* GET handler for group Member
 */
static void
GM_hnd_get_member(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemented");
  return;	
}


/* GET policies handler for group 
 */
static void
GM_hnd_get_policies(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}

/* FETCH pub-key handler for group 
 */
static void
GM_hnd_fetch_pubkey(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}

/* GET pub-key handler for group 
 */
static void
GM_hnd_get_pubkey(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}


/* GET num handler for group 
 */
static void
GM_hnd_get_num(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}

/* GET active handler for group 
 */
static void
GM_hnd_get_active(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}


/* DELETE handler for group 
 */
static void
GM_hnd_delete_grp(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}


/* GET handler for group 
 */
static void
GM_hnd_get_grp(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}

/* DELETE handler for group Member
 */
static void
GM_hnd_delete_member(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request UNUSED_PARAM,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response UNUSED_PARAM
) 
{
  oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemnted");
  return; 
}

/*
 * Member resource creation handler 
 * - creates member resource to be filled in with PUT, GET and DELETE handler
 */
static uint8_t
GM_insert_mbr_resource( coap_context_t  *ctx, 
               coap_string_t *uri_path, coap_pdu_t *response){

  /*
   * Check if this resource already exists
   */

 coap_resource_t *r =
   coap_get_resource_from_uri_path(ctx, (coap_str_const_t *)uri_path);
   if (r == NULL){ 
       coap_resource_t *r =
        coap_resource_init((coap_str_const_t *)uri_path,
           COAP_RESOURCE_FLAGS_RELEASE_URI | resource_flags);
       coap_register_handler(r, COAP_REQUEST_PUT,
                                               GM_hnd_put_member);
       coap_register_handler(r, COAP_REQUEST_GET,
                                               GM_hnd_get_member);
       coap_register_handler(r, COAP_REQUEST_DELETE,
                                            GM_hnd_delete_member);
       coap_add_attr(r, coap_make_str_const("ct"), 
           coap_make_str_const("60"), 0);
       coap_add_attr(r, coap_make_str_const("title"),
           coap_make_str_const("\"Secure Group member\""), 0);
       coap_add_attr(r, coap_make_str_const("rt"),
           coap_make_str_const("\"core.osc.j\""), 0);
       coap_add_attr(r, coap_make_str_const("if"),
           coap_make_str_const("\"ace.group\""), 0);
       coap_add_resource(ctx, r);
       return 0;
     } /* if r == NULL*/
   return 1;
}



/*
 * POST handler - /GM/GRP
 * receives request to add a member to group
 */
void
GM_hnd_post_grp(coap_context_t *ctx,
                coap_resource_t *resource UNUSED_PARAM,
                coap_session_t *session UNUSED_PARAM,
                coap_pdu_t *request,
                coap_binary_t *token UNUSED_PARAM,
                coap_string_t *query UNUSED_PARAM,
                coap_pdu_t *response
) {
  coap_string_t *uri_path;
  uri_path = coap_get_uri_path(request);
  if (!uri_path) {
    oscore_error_return(COAP_RESPONSE_CODE(404), 
      response, "Uri path does not exist");
    return;
  }
  uint8_t* data = NULL;
  size_t size = 0;
  /* length of "GM/" is 3  */
  GM_group_t *group = GM_find_group((char *)uri_path->s + 3, 
                              uri_path->length - 3);
  if (group == NULL){
    oscore_error_return(COAP_RESPONSE_CODE(401), 
    response, "Group does not exist");
    return;
  }
  data = assemble_data(resource, request, response, &size);
  if ((data == NULL) | (size == 0))return;
  
    joinreq_t *jr = GM_join_request(&data);
    if (jr == NULL){
      oscore_error_return(COAP_RESPONSE_CODE(400), 
      response, "Join request incorrect");
      return;
    } /* ok */
    GM_print_jr(jr);
    if (jr->signature != NULL){
/* prepare cose_sign1 for verification of 
                the kdcchallenge signature */
      uint8_t *cat_nonce = coap_malloc((2*NONCE_LEN) + jr->scope_len);
      for (uint qq = 0; qq < jr->scope_len; qq++)
                    cat_nonce[qq] = jr->scope[qq]; 
      for (uint qq =0; qq < NONCE_LEN; qq++){
		  cat_nonce[qq + jr->scope_len] = kdcchallenge[qq];
		  cat_nonce[qq+NONCE_LEN + jr->scope_len] = jr->cnonce[qq];
	  }
      cose_sign1_t sign[1];
      cose_sign1_init(sign);  /* clear sign memory */
      cose_sign1_set_alg(sign, COSE_Algorithm_EdDSA,
                             COSE_Elliptic_Curve_Ed25519, COSE_KTY_OKP);
      cose_sign1_set_signature(sign, jr->signature);
      cose_sign1_set_ciphertext(sign, cat_nonce, (2*NONCE_LEN) + jr->scope_len); 
      cose_sign1_set_public_key(sign, jr->pub_key);
      cose_sign1_set_private_key( sign, NULL);
      int sign_res = cose_sign1_verify(sign);
      fprintf(stderr,"signature verified \n");
      if (sign_res == 0){
        oscore_error_return(COAP_RESPONSE_CODE(400), 
        response, "OSCORE signature verification Failure");
        GM_delete_jr(jr);
        return;
      } /* if sign_res  */
    } /* if jr->signature  */
    response->code = COAP_RESPONSE_CODE(201);
    GM_member_t *member = coap_malloc( sizeof(GM_member_t));
    memset(member, 0 , sizeof(GM_member_t));
    member->next = group->members;
    group->members = member;
    group->epoch++;
    group->members_len++;
    GM_jr_to_member(jr, member, group);
 /* insert resource GM/GRP/nodes/<member> */
    char nodes[] = "/nodes/";
    coap_string_t *mbr_path = coap_new_string(uri_path->length + 
                            strlen(nodes) + member->client_id_len+1);
    for (uint qq = 0; qq < uri_path->length; qq++)mbr_path->s[qq] = uri_path->s[qq];
    memcpy(mbr_path->s + uri_path->length, nodes, 8);
    memcpy(mbr_path->s + uri_path->length + 8, member->client_id, member->client_id_len);
    mbr_path->length = uri_path->length + member->client_id_len+1 + strlen(nodes);           
    uint8_t ok = GM_insert_mbr_resource( ctx, mbr_path, response);
    GM_delete_jr(jr);
    if (ok != 0)return;
 /* insert resource GM/GRP/nodes/<member>/pub-key */
    char pubkey[] = "/pub-key";
    size_t pkl = strlen(pubkey);
    coap_string_t * uriGMderiv = coap_new_string(pkl + mbr_path->length);
    memcpy(uriGMderiv->s, mbr_path->s, mbr_path->length);
    memcpy(uriGMderiv->s+mbr_path->length, pubkey, pkl);
    uriGMderiv->length = pkl + mbr_path->length;
    coap_resource_t *r = GM_insert_grp_resource(ctx, uriGMderiv, response);
    if (r != NULL)
        coap_register_handler(r, COAP_REQUEST_POST,
                                         GM_hnd_post_member_pubkey);
    GM_join_response(response, group, member);
    GM_print_group( group);
    return;
}


/*
 * Group resource creation POST handler 
 * - creates group resource to be filled in with POST
 */
coap_resource_t *
GM_insert_grp_resource( coap_context_t  *ctx, 
               coap_string_t *uri_path, coap_pdu_t *response){


  /*
   * Check if this resource already exists
   */
  
  coap_resource_t *r =
   coap_get_resource_from_uri_path(ctx, (coap_str_const_t *)uri_path);
   if (r == NULL){ 
      coap_resource_t *r =
        coap_resource_init((coap_str_const_t *)uri_path, 
          COAP_RESOURCE_FLAGS_RELEASE_URI | resource_flags);
      coap_add_attr(r, coap_make_str_const("ct"), 
           coap_make_str_const("60"), 0);
      coap_add_attr(r, coap_make_str_const("title"),
           coap_make_str_const("\"Secure Group\""), 0);
      coap_add_attr(r, coap_make_str_const("rt"),
           coap_make_str_const("\"ace.oscore.gm\""), 0);
      coap_add_attr(r, coap_make_str_const("if"),
           coap_make_str_const("\"ace.oscore.gm\""), 0);
      coap_add_resource(ctx, r);
      return r;
  }
  return NULL;
}


/*
 * POST handler - /GM/manage
 * receives request to create oscore group
 */
void
GM_hnd_post_manage(coap_context_t  *ctx,
             struct coap_resource_t *resource UNUSED_PARAM,
             coap_session_t *session UNUSED_PARAM,
             coap_pdu_t *request,
             coap_binary_t *no_token UNUSED_PARAM,
             coap_string_t *query UNUSED_PARAM,
             coap_pdu_t *response)
{
  coap_string_t *uriGMident = NULL;
  char        GM[3]  = "GM/";
  struct GM_group_t *current = NULL;
  uint8_t* data = NULL;
  size_t size = 0;
  size_t gl = 3;
  data = assemble_data(resource, request, response, &size);
  if ((data == NULL) | (size == 0))return;
  
    GM_group_t *grp = GM_manage_request(&data);
    if (grp == NULL){
      oscore_error_return(COAP_RESPONSE_CODE(401), 
        response, "Request data is invalid");
      return;
    }  /* if grp */
    current = GM_find_group((char *)grp->group_name, 
                              grp->group_name_len);
    if(current == NULL){
      GM_enter_group(grp);
      current = grp;
/* create new resource with path /GM/<ident> */
      uriGMident = coap_new_string(gl + grp->group_name_len);
      memcpy(uriGMident->s, GM, gl);
      memcpy(uriGMident->s+gl, grp->group_name, grp->group_name_len);
      uriGMident->length = grp->group_name_len + gl;
      current->joining_uri = coap_malloc(uriGMident->length);
      current->joining_uri_len = uriGMident->length;
      memcpy(current->joining_uri, uriGMident->s, current->joining_uri_len);
      coap_resource_t *r = GM_insert_grp_resource(ctx, uriGMident, response);
      if (r != NULL){
        coap_register_handler(r, COAP_REQUEST_POST,
                                               GM_hnd_post_grp);
        coap_register_handler(r, COAP_REQUEST_GET,
                                               GM_hnd_get_grp);
        coap_register_handler(r, COAP_REQUEST_DELETE,
                                              GM_hnd_delete_grp);
      }
/* create manage resource with path /GM/<ident>/pubkey */
      char pubkey[] = "/pub-key";
      size_t pkl = strlen(pubkey);
      coap_string_t *uriGMpub = coap_new_string(pkl + uriGMident->length);
      memcpy(uriGMpub->s, uriGMident->s, uriGMident->length);
      memcpy(uriGMpub->s+uriGMident->length, pubkey, pkl);
      uriGMpub->length = pkl + uriGMident->length;
      r = GM_insert_grp_resource(ctx, uriGMpub, response);
      if (r != NULL){
        coap_register_handler(r, COAP_REQUEST_FETCH,
                                               GM_hnd_fetch_pubkey);
        coap_register_handler(r, COAP_REQUEST_GET,
                                               GM_hnd_get_pubkey);
      }
/* create manage resource with path /GM/<ident>/policies */

      char policies[] = "/policies";
      pkl = strlen(policies);
      coap_string_t *uriGMpolicy = coap_new_string(pkl + uriGMident->length);
      memcpy(uriGMpolicy->s, uriGMident->s, uriGMident->length);
      memcpy(uriGMpolicy->s+uriGMident->length, policies, pkl);
      uriGMpolicy->length = pkl + uriGMident->length;
      r = GM_insert_grp_resource(ctx, uriGMpolicy, response);
      if (r != NULL){
        coap_register_handler(r, COAP_REQUEST_GET,
                                               GM_hnd_get_policies);
      }
/* create manage resource with path /GM/<ident>/num */
      char num[] = "/num";
      pkl = strlen(num);
      coap_string_t *uriGMnum = coap_new_string(pkl + uriGMident->length);
      memcpy(uriGMnum->s, uriGMident->s, uriGMident->length);
      memcpy(uriGMnum->s+uriGMident->length, num, pkl);
      uriGMnum->length = pkl + uriGMident->length;
      r = GM_insert_grp_resource(ctx, uriGMnum, response);
      if (r != NULL){
        coap_register_handler(r, COAP_REQUEST_GET,
                                               GM_hnd_get_num);
      }   
 /* create manage resource with path /GM/<ident>/active */
      char active[] = "/active";
      pkl = strlen(active);
      coap_string_t *uriGMactive = coap_new_string(pkl + uriGMident->length);
      memcpy(uriGMactive->s, uriGMident->s, uriGMident->length);
      memcpy(uriGMactive->s+uriGMident->length, active, pkl);
      uriGMactive->length = pkl + uriGMident->length;
      r = GM_insert_grp_resource(ctx, uriGMactive, response);
      if (r != NULL){
        coap_register_handler(r, COAP_REQUEST_GET,
                                               GM_hnd_get_active);
      }        
/* fill in group characteristics       */
      GM_initial_conf(current->attributes);
      GM_print_group(current);
      response->code = COAP_RESPONSE_CODE(201);
      unsigned char opt_buf[5]; 
      char uri_GM[] = "GM";
      coap_add_option(response,
                    COAP_OPTION_LOCATION_PATH,
                    2,
                    (uint8_t *)uri_GM);
      coap_add_option(response,
                    COAP_OPTION_LOCATION_PATH,
                    grp->group_name_len,
                    grp->group_name);
      coap_add_option(response,
                 COAP_OPTION_CONTENT_FORMAT,
                 coap_encode_var_safe(opt_buf, sizeof(opt_buf),
                 COAP_MEDIATYPE_APPLICATION_ACE_GROUPCOMM_CBOR), opt_buf);
      GM_group_response(response, current);
      return;
    } else {  /* current != NULL  */
      coap_log(LOG_WARNING,"Group already exists \n");
      oscore_error_return(COAP_RESPONSE_CODE(400), 
                          response, "Group already exists");
      return;
    }  /* if current  */
}

/*
 * POST handler - /authz-info
 * receives CWT with authorization to join oscore group
 */
void
GM_hnd_post_authz(coap_context_t  *ctx UNUSED_PARAM,
             struct coap_resource_t *resource UNUSED_PARAM,
             coap_session_t *session UNUSED_PARAM,
             coap_pdu_t *request,
             coap_binary_t *no_token UNUSED_PARAM,
             coap_string_t *query UNUSED_PARAM,
             coap_pdu_t *response)
{
  oauth_cwtkey_t *key_enc = NULL;
  size_t size;
  uint8_t *data;
  oauth_token_t *token = NULL;
  uint8_t *nonce1 = NULL;
/* two authorizations can be returned:
 * 1) authorization to create group
 * 2) authorization to join member
 */
  struct GM_group_t *current = NULL;
  data = assemble_data(resource, request, response, &size);
  if ((data == NULL) | (size == 0))return;
  
    if (oauth_strip(&data, &nonce1, &key_enc) == 1){
      coap_log(LOG_WARNING,"Cannot extract CWT");
      oscore_error_return(COAP_RESPONSE_CODE(400), 
                      response, "Cannot extract CWT");
      return;
    } /* if oauth_strip  */
/*  keyenc points to algorithm information 
    data points to encrypted CWT contained in CBOR_BYTE_STRING
    decryption is possible  */
  uint8_t aad_buffer[35];
  uint8_t *enc_token = key_enc->data;
  uint8_t elem = cbor_get_next_element(&enc_token);
  if (elem != CBOR_TAG){
    coap_log(LOG_WARNING, "No CWT tag found \n");
    oscore_error_return(COAP_RESPONSE_CODE(400), 
            response, "No CWT tag found");
    return;
  }
  size_t aad_len = GM_prepare_aad(
                   COSE_Algorithm_AES_CCM_16_64_128, aad_buffer);
  token = oauth_decrypt_token(&enc_token, ASGM_KEY, aad_buffer, aad_len);
  if (token == NULL){
	  coap_log(LOG_WARNING, "token not decoded  \n");
      oscore_error_return(COAP_RESPONSE_CODE(401), 
                         response, "token not decoded");
      return;
  }
  GM_scope_t *scope = GM_get_scope(token->scope); 
  if (scope == NULL){
	  coap_log(LOG_WARNING, "scope not found  \n");
      oscore_error_return(COAP_RESPONSE_CODE(401), 
                         response, "scope not found");
      return;
  }
  if(scope->roles != SCOPE_ROLE_ADMINISTRATOR){
/* authorization for client join: find group */
    current = GM_find_group((char *)scope->group_id, 
                              scope->group_id_len);
    if(current == NULL){
	  coap_free(scope);
      coap_log(LOG_WARNING, "group does not exist  \n");
      oscore_error_return(COAP_RESPONSE_CODE(401), 
                         response, "Group does not exist");
      return;
    }
  } /* if group_admin */
  coap_free(scope);
/* nonce1 contains received 8-byte nonce      */
  oauth_cnf_t *pt= token->osc_sec_config;
/* create kdcchallenge for key signature  */
  if (kdcchallenge != NULL) free(kdcchallenge);
  kdcchallenge = coap_malloc(NONCE_LEN);
  prng(kdcchallenge, NONCE_LEN);
/* nonce2 is nonce returned for salt generation */
  uint8_t *nonce2 = coap_malloc(NONCE_LEN);
  prng(nonce2, NONCE_LEN);
  uint8_t  *ms_salt = coap_malloc(24);
  for (int qq =0 ; qq < NONCE_LEN; qq ++){
     ms_salt[qq + 16] = nonce2[qq];
     ms_salt[qq+8] = nonce1[qq];
     ms_salt[qq] = pt->salt[qq];
  }
  coap_free(nonce1);
  GM_create_context(token, ms_salt);
  oauth_delete_token(token);
  GM_return_nonce(response, nonce2, kdcchallenge);
  coap_free(ms_salt);
  coap_free(nonce2);
  GM_print_group(current);
  response->code = COAP_RESPONSE_CODE(201);
  return;
}

void
GM_init_resources(coap_context_t *ctx) {
  if (ctx->osc_ctx != NULL){
	 oscore_add_group_keys(ctx->osc_ctx,
        public_key_C0, NULL,  
        public_key_C1, private_key_C1);
  /* receiver public key added */
  size_t cs_params_len = 0;
  uint8_t *cs_params = GM_cs_params(COSE_Elliptic_Curve_Ed25519, COSE_KTY_OKP, &cs_params_len);
  oscore_add_group_algorithm(ctx->osc_ctx,  
        COSE_Algorithm_EdDSA, 
        cs_params, cs_params_len);
  coap_free(cs_params);
  }
  
  coap_resource_t *r;

  r = coap_resource_init(NULL, 0);

r = coap_resource_init(coap_make_str_const("GM/authz-info"), resource_flags);
  coap_register_handler(r, COAP_REQUEST_POST, GM_hnd_post_authz);
  coap_add_attr(r, coap_make_str_const("ct"), coap_make_str_const("60"), 0);
  coap_add_attr(r, coap_make_str_const("title"), coap_make_str_const("\"Authorization\""), 0);
  coap_add_attr(r, coap_make_str_const("rt"), coap_make_str_const("\"ace.oscore.gm\""), 0);
  coap_add_attr(r, coap_make_str_const("if"), coap_make_str_const("\"ace.group\""), 0);

  coap_add_resource(ctx, r);

r = coap_resource_init(coap_make_str_const("GM/manage"), resource_flags);
  coap_register_handler(r, COAP_REQUEST_POST, 
                                      GM_hnd_post_manage);
  coap_add_attr(r, coap_make_str_const("ct"), coap_make_str_const("60"), 0);
  coap_add_attr(r, coap_make_str_const("title"), coap_make_str_const("\"Management\""), 0);
  coap_add_attr(r, coap_make_str_const("rt"), coap_make_str_const("\"ace.oscore.gm\""), 0);
  coap_add_attr(r, coap_make_str_const("if"), coap_make_str_const("\"ace.group\""), 0);

  coap_add_resource(ctx, r);
  
}



