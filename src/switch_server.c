/* switch-server -- implementation of ocf Switch using
 * a simple implementation of the Constrained Application Protocol (CoAP)
 *         as defined in RFC 7252
 * OCF switch (SW) server is added by:
 * Peter van der Stok <consultancy@vanderstok.org>
 * This file relies on oscore
 *

 * This file is part of the CoAP library libcoap. Please see README for terms
 * of use.
 *
 * authorization for access are created by authz-info
 */

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <sys/types.h>
#include <ifaddrs.h>
#include <sys/stat.h>
#include <errno.h>
#include <signal.h>
#ifdef _WIN32
#define strcasecmp _stricmp
#include "getopt.c"
#if !defined(S_ISDIR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#endif
#else
#include <unistd.h>
#include <sys/select.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <dirent.h>
#include <time.h>
#endif

#include "switch_server.h"
#include "oscore_oauth.h"
#include "coap_server.h"
#include "oscore.h"
#include "oscore-context.h"
#include "cbor.h"
#include "cose.h"
#include "coap.h"

#ifdef __GNUC__
#define UNUSED_PARAM __attribute__ ((unused))
#else /* not a GCC */
#define UNUSED_PARAM
#endif /* GCC */

#define BOOT_KEY    1
#define BOOT_NAME   2

/* reference to AS; to be returned when no oscore encryption */
static uint8_t *IP_AS = NULL;
static size_t  IP_AS_len = 0;

/* name and IP address of switch to be used in AS */
static coap_string_t IP_SW = {.length =0, .s = NULL};
static coap_string_t SW_identifier = {.length =0, .s = NULL};


/* local IP adresses  contained in "ocf_eps" */
typedef struct ocf_ep_t{
	struct ocf_ep_t *next;
	coap_string_t   ep;
} ocf_ep_t;

static struct ocf_ep_t  *ocf_eps = NULL;
static size_t ocf_ep_nr = 0;


/* shared key between AS and Switch */
static uint8_t *ASSW_KEY = NULL;
// static size_t  ASSW_KEY_LEN = 0;
static uint8_t *ASSW_key_id = NULL;
static size_t  ASSW_key_id_len = 0; 
// static uint8_t ASSW_IV[COSE_algorithm_AES_CCM_16_64_128_IV_LEN];

/* rsnonce generated by server and combined with cnonce of join */
static uint8_t *rsnonce = NULL;

static uint8_t switch_value = 0;

/* stores data for block2 return */
coap_string_t SW_ret_data = {
	.length = 0,
	.s = NULL
};



/* cr_namenr(uint8_t *result)
 * creates identifier of 6 ciphers for unique name
 */
static void
cr_namenr(uint8_t * result){
   uint32_t numb=rand();
   for (uint8_t qq=0; qq < 6; qq++){
     uint32_t numb10 = numb/10;
     result[qq] = numb -10*numb10 +0x30;
     numb = numb10;
   }
}



/* cbor description of oic/res resource */
static size_t
desc_res(uint8_t **data){
	char href[] = "href";
	char res[]  = "oic/res";
	char rel[]  = "rel";
	char self[] = "self";
	char rt[]   = "rt";
	char wk[]   = "oic.wk.res";
	char ifx[]  = "if";
	char ifll[] = "oic.if.ll";
	char base[] = "oic.if.baseline";
	char pp[]   = "p";
	char bm[]   = "bm";
	char epsx[] = "eps";
	size_t ret = cbor_put_map(data, 6);
	ret += cbor_put_text(data, href, 4);
	ret += cbor_put_text(data, res, 7);
	ret += cbor_put_text(data, rel, 3);
	ret += cbor_put_text(data, self, 4);
	ret += cbor_put_text(data, rt, 2);
	ret += cbor_put_array(data, 1);
	ret += cbor_put_text(data, wk, 10);	
    ret += cbor_put_text(data, ifx, 2);
	ret += cbor_put_array(data, 2);
	ret += cbor_put_text(data, ifll, 9);	  
	ret += cbor_put_text(data, base, 15);
	ret += cbor_put_text(data, pp, 1);	 
    ret += cbor_put_map(data, 1);  
    ret += cbor_put_text(data, bm, 2);
    ret += cbor_put_number(data, 3);
	ret += cbor_put_text(data, epsx, 3);
	ret += cbor_put_array(data, ocf_ep_nr);
	struct ocf_ep_t  *eps = ocf_eps;
	while (eps != NULL){
	    ret += cbor_put_text(data, (char *)eps->ep.s, eps->ep.length);
	    eps = eps->next;	
    }  
    return ret;  
}

/* cbor description of oic/p resource */
static size_t
desc_p(uint8_t **data){
    char href[] = "href";
	char oip[]  = "oic/p";
	char rt[]   = "rt";
	char wk[]   = "oic.wk.p";
	char ifx[]  = "if";
	char ifr[]  = "oic.if.r";
	char base[] = "oic.if.baseline";
	char pp[]   = "p";
	char bm[]   = "bm";
	char epsx[] = "eps";
	size_t ret = cbor_put_map(data, 5);
	ret += cbor_put_text(data, href, 4);
	ret += cbor_put_text(data, oip, 5);
	ret += cbor_put_text(data, rt, 2);
	ret += cbor_put_array(data, 1);
	ret += cbor_put_text(data, wk, 8);	
    ret += cbor_put_text(data, ifx, 2);
	ret += cbor_put_array(data, 2);
	ret += cbor_put_text(data, ifr, 8);	  
	ret += cbor_put_text(data, base, 15);
	ret += cbor_put_text(data, pp, 1);	 
    ret += cbor_put_map(data, 1);  
    ret += cbor_put_text(data, bm, 2);
    ret += cbor_put_number(data, 3);
	ret += cbor_put_text(data, epsx, 3);
	ret += cbor_put_array(data, ocf_ep_nr);
	struct ocf_ep_t  *eps = ocf_eps;
	while (eps != NULL){
	    ret += cbor_put_text(data, (char *)eps->ep.s, eps->ep.length);
	    eps = eps->next;	
    }  
    return ret;  
}

/* cbor description of oic/d resource */
static size_t
desc_d(uint8_t **data){
    char href[] = "href";
	char oid[]  = "oic/d";
	char rt[]   = "rt";
	char wk[]   = "oic.wk.d";
	char ifx[]  = "if";
	char ifl[]  = "oic.if.ll";
	char base[] = "oic.if.baseline";
	char pp[]   = "p";
	char bm[]   = "bm";
	char epsx[] = "eps";
	size_t ret = cbor_put_map(data, 5);
	ret += cbor_put_text(data, href, 4);
	ret += cbor_put_text(data, oid, 5);
	ret += cbor_put_text(data, rt, 2);
	ret += cbor_put_array(data, 1);
	ret += cbor_put_text(data, wk, 8);	
    ret += cbor_put_text(data, ifx, 2);
	ret += cbor_put_array(data, 2);
	ret += cbor_put_text(data, ifl, 9);	  
	ret += cbor_put_text(data, base, 15);
	ret += cbor_put_text(data, pp, 1);	 
    ret += cbor_put_map(data, 1);  
    ret += cbor_put_text(data, bm, 2);
    ret += cbor_put_number(data, 3);
	ret += cbor_put_text(data, epsx, 3);
	ret += cbor_put_array(data, ocf_ep_nr);
	struct ocf_ep_t  *eps = ocf_eps;
	while (eps != NULL){
	    ret += cbor_put_text(data, (char *)eps->ep.s, eps->ep.length);
	    eps = eps->next;	
    }  
    return ret;  
}

/* cbor description of oic/onoff resource */
static size_t
desc_onoff(uint8_t **data){
    char href[] = "href";
	char onf[]  = "/onoff";
	char rt[]   = "rt";
	char sb[]   = "oic.r.switch.binary";
	char ifx[]  = "if";
	char ifa[]  = "oic.if.a";
	char base[] = "oic.if.baseline";
	char pp[]   = "p";
	char bm[]   = "bm";
	char epsx[] = "eps";
	size_t ret = cbor_put_map(data, 5);
	ret += cbor_put_text(data, href, 4);
	ret += cbor_put_text(data, onf, 6);
	ret += cbor_put_text(data, rt, 2);
	ret += cbor_put_array(data, 1);
	ret += cbor_put_text(data, sb, 19);	
    ret += cbor_put_text(data, ifx, 2);
	ret += cbor_put_array(data, 2);
	ret += cbor_put_text(data, ifa, 8);	  
	ret += cbor_put_text(data, base, 15);
	ret += cbor_put_text(data, pp, 1);	 
    ret += cbor_put_map(data, 1);  
    ret += cbor_put_text(data, bm, 2);
    ret += cbor_put_number(data, 3);
	ret += cbor_put_text(data, epsx, 3);
	ret += cbor_put_array(data, ocf_ep_nr);
	struct ocf_ep_t  *eps = ocf_eps;
	while (eps != NULL){
	    ret += cbor_put_text(data, (char *)eps->ep.s, eps->ep.length);
	    eps = eps->next;	
    }  
    return ret;  
}

static void
SW_return_bootkey(coap_string_t *response)
{
  int nr =0;
  uint8_t req_buf[30];
  uint8_t *buf = req_buf;
  if (ASSW_KEY != NULL)free(ASSW_KEY);
  ASSW_KEY = coap_malloc(COSE_algorithm_AES_CCM_16_64_128_KEY_LEN);
  prng(ASSW_KEY, COSE_algorithm_AES_CCM_16_64_128_KEY_LEN);

  nr += cbor_put_map(&buf, 2);
  nr += cbor_put_number(&buf, BOOT_KEY);
  nr += cbor_put_bytes(&buf, ASSW_KEY, COSE_algorithm_AES_CCM_16_64_128_KEY_LEN);
  nr += cbor_put_number(&buf, BOOT_NAME);
  nr += cbor_put_bytes(&buf, SW_identifier.s, SW_identifier.length);
  response->length = nr;
  response->s = coap_malloc(nr);
  memcpy(response->s,req_buf, nr);
  return;
}

/* SW_return_AS
 * returns address of AS  
 */
static void
SW_return_AS(coap_string_t *response)
{
  int nr =0;
  uint8_t req_buf[30];
  uint8_t *buf = req_buf;
 
  if (IP_AS != NULL){ 
	nr += cbor_put_map(&buf, 1);
    nr += cbor_put_number(&buf, OAUTH_CRH_AS);
    nr += cbor_put_text(&buf, (char *)IP_AS, IP_AS_len);
  }
  response->length = nr;
  response->s = coap_malloc(nr);
  memcpy(response->s,req_buf, nr);
  return;
}



/* SW_return_nonce
 * returns nonce  
 */
static void
SW_return_nonce(coap_string_t *response, uint8_t *cnonce)
{
  int nr =0;
  uint8_t req_buf[30];
  uint8_t *buf = req_buf;
 
  if (cnonce != NULL){ 
	nr += cbor_put_map(&buf, 1);
    nr += cbor_put_number(&buf, OAUTH_OSC_PROF_NONCE2);
    nr += cbor_put_bytes(&buf, cnonce, 8);
  }
  response->length = nr;
  response->s = coap_malloc(nr);
  memcpy(response->s,req_buf, nr);
  return;
}



/* switch_create_context
 * creates context from information stored in token and salt_loc
 */
static void
switch_create_context(oauth_token_t *token, uint8_t *nonce){
  
  oauth_cnf_t *pt = token->osc_sec_config;
  uint8_t *rid  = coap_malloc(pt->server_id_len);
  uint8_t *cid  = coap_malloc(pt->client_id_len);
  uint8_t *ctid = coap_malloc(pt->context_id_len);
  uint8_t *ms   = coap_malloc(pt->ms_len);
  
  for (uint8_t qq =0; qq < pt->ms_len; qq++) 
                     ms[qq] = pt->ms[qq];
  for (uint8_t qq =0; qq < pt->client_id_len; qq++) 
                     cid[qq] = pt->client_id[qq];
  for (uint8_t qq =0; qq < pt->server_id_len; qq++) 
                     rid[qq] = pt->server_id[qq];
  for (uint8_t qq =0; qq < pt->context_id_len; qq++) 
                     ctid[qq] = pt->context_id[qq];
  oscore_ctx_t *osc_ctx = oscore_derive_ctx(
    pt->ms, pt->ms_len, nonce, 24, 
    pt->alg,
    cid, pt->client_id_len, 
    rid, pt->server_id_len, 
    ctid, pt->context_id_len,
    OSCORE_DEFAULT_REPLAY_WINDOW);
    pt->ms = NULL;
    pt->ms_len = 0;
  oscore_enter_context(osc_ctx);
}



/*
 * Return error and error message
 */
static void
oscore_error_return(uint8_t error, coap_pdu_t *response,
                                       const char *message){
  unsigned char opt_buf[5];
  coap_log(LOG_WARNING,"%s",message);
  response->code = error;
  response->data = NULL;
  response->used_size = response->token_length;
  coap_add_option(response,
                COAP_OPTION_CONTENT_FORMAT,
                coap_encode_var_safe(opt_buf, sizeof(opt_buf),
                COAP_MEDIATYPE_TEXT_PLAIN), opt_buf);
  coap_add_data(response, strlen(message), 
                                  (const uint8_t *)message);
}

/*
 * POST handler - /oic/onoff
 * receives request to set the switch value
 */
void
ocf_hnd_post_switch(coap_context_t *ctx UNUSED_PARAM,
                coap_resource_t *resource,
                coap_session_t *session,
                coap_pdu_t *request,
                coap_binary_t *token,
                coap_string_t *query,
                coap_pdu_t *response
) {
  /* resource is found; handle the switch request  */
  uint8_t* data = NULL;
  size_t size = 0; 


  data = assemble_data(session, request, response, &size);
  if (data == (void *)-1)return;  /* more blocks to arrive */
  if ((data == NULL)| (size == 0)){
	  oscore_error_return(COAP_RESPONSE_CODE(400), 
      response, "Did not find request data\n");
	  return;
  }
    if (!session->oscore_encryption){
	   if(SW_ret_data.s != NULL)coap_free(SW_ret_data.s);
       SW_return_AS(&SW_ret_data);
       response->code = COAP_RESPONSE_CODE(401);
       coap_add_data_blocked_response(resource, session, request, response, token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 SW_ret_data.length, SW_ret_data.s);
     return;
    }
    if ( query == NULL){
	  oscore_error_return(COAP_RESPONSE_CODE(400), 
      response, "No query present\n");
	  return;
	}
	if ((strncmp("if=oic.if.a", (char *)query->s, query->length) != 0)
	  || (query->length != 11)){
      oscore_error_return(COAP_RESPONSE_CODE(400), 
      response, "illegal if specification\n");
	  return;
	}
	uint8_t  elem = cbor_get_next_element(&data);
    if (elem == CBOR_MAP){ 
	 uint8_t *property = NULL;
	 char value[] = "value";
	 size_t property_len = 0;
      uint64_t map_size = cbor_get_element_size(&data);
      for (uint i=0 ; i < map_size; i++){
        cbor_get_string_array(&data, &property, &property_len);
        if (property_len > 0 && property != NULL){
			if ((strncmp(value, 
                       (char *)property, property_len) == 0)
                       && (property_len == 5)){
			  elem = cbor_get_next_element(&data);
			  if (elem != CBOR_SIMPLE_VALUE){
			    oscore_error_return(COAP_RESPONSE_CODE(400), 
                          response, "not a boolean value");
	               return;
			  }
			  uint8_t bolval = cbor_get_element_size(&data);
			  if (bolval == CBOR_FALSE){  /* false */
				  switch_value = 0;
				  fprintf(stderr,"switch is off\n");
			  } else if (bolval == CBOR_TRUE){  /*true */
				  switch_value = 1;
				  fprintf(stderr,"switch is on \n");
			  } else {			  
                     oscore_error_return(COAP_RESPONSE_CODE(400), 
                     response, "not a boolean value");
	              return;				  
			  }
			}  /* if strncmp */
	    }  /* if property_len > */
        else{
          oscore_error_return(COAP_RESPONSE_CODE(400), 
          response, "Decode error in switch payload");
          return;
        } /* if property_len > */
      } /* for map_size  */
      response->code = COAP_RESPONSE_CODE(201);
    } /* if elem */
    coap_add_data_blocked_response(resource, session, request, response, token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 0, NULL);
    return;
}


/* switch_get_scope
 * fills the scope array of token
 * from the received CBOR map stored in the token->scope
 */
static uint8_t
switch_get_scope(uint8_t *data, uint8_t **scope, size_t *len){
  return cbor_get_string_array(&data, scope, len);
}


/* switch_prepare_aad
 * prepares aad for switch client and server 
 * to encrypt and decrypt
 */
static size_t
switch_prepare_aad(int8_t alg, uint8_t *aad_buffer){
  size_t ret = 0;
  uint8_t buffer[10];
  uint8_t *buf = buffer;
  size_t buf_len = 0;
  buf_len += cbor_put_map(&buf, 1);
  buf_len += cbor_put_number(&buf, COSE_HP_ALG);
  buf_len += cbor_put_number(&buf, alg);
  char encrypt0[] = "Encrypt0";
  /* Begin creating the AAD */
  ret += cbor_put_array(&aad_buffer, 3);
  ret += cbor_put_text(&aad_buffer, encrypt0, strlen(encrypt0));
  ret += cbor_put_bytes(&aad_buffer, buffer, buf_len);
  ret += cbor_put_bytes(&aad_buffer, NULL, 0); 
  return ret;
}

/*
 * GET handler - /oic/d
 * standard ocf well-known device discovery
 */
static void
ocf_hnd_wk_d(coap_context_t  *ctx UNUSED_PARAM,
             struct coap_resource_t *resource,
             coap_session_t *session,
             coap_pdu_t *request,
             coap_binary_t *token,
             coap_string_t *query UNUSED_PARAM,
             coap_pdu_t *response)
{
	 oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemented");
}

/*
 * GET handler - /oic/p
 * standard ocf well-known platform discovery
 */
static void
ocf_hnd_wk_p(coap_context_t  *ctx UNUSED_PARAM,
             struct coap_resource_t *resource,
             coap_session_t *session,
             coap_pdu_t *request,
             coap_binary_t *token,
             coap_string_t *query UNUSED_PARAM,
             coap_pdu_t *response)
{
	 oscore_error_return(COAP_RESPONSE_CODE(400), 
     response, "Not implemented");
}


/*
 * GET handler - /oic/res
 * standard ocf well-known resource discovery
 */
static void
ocf_hnd_wk_res(coap_context_t  *ctx UNUSED_PARAM,
             struct coap_resource_t *resource,
             coap_session_t *session,
             coap_pdu_t *request,
             coap_binary_t *token,
             coap_string_t *query,
             coap_pdu_t *response)
{
  size_t nr = 0;
  uint8_t *req_buf = coap_malloc(1000);
  uint8_t *buf = req_buf;
  nr += cbor_put_array(&buf, 4); /* 4 resources  */
  if (query){
	 fprintf(stderr,"query is :  %s \n", query->s);
	 if ((strncmp("rt=oic.if.baseline", (char *)query->s, query->length) == 0)
	        && (query->length == 18)){
		 nr += desc_res(&buf);
		 fprintf(stderr, "desc_res done nr = %d\n", (int)nr);
		 nr += desc_p(&buf);
		 fprintf(stderr, "desc_p done nr = %d\n", (int)nr);
		 nr += desc_d(&buf);
		 fprintf(stderr, "desc_d done nr = %d\n", (int)nr);
		 nr += desc_onoff(&buf);
		 fprintf(stderr, "desc_onoff done nr = %d\n", (int)nr);
	 } 
	 else if ((strncmp("rt=oic.if.ll", (char *)query->s, query->length) == 0)
	        && ( query->length == 11)){
		 oscore_error_return(COAP_RESPONSE_CODE(400), 
             response, "oic.if.ll to be implemented");
             return;
	 }
	 else{
	   oscore_error_return(COAP_RESPONSE_CODE(400), 
             response, "Bad request");
             return;
	 }
  }  /* query */
  else {
	oscore_error_return(COAP_RESPONSE_CODE(400), 
             response, "Bad request");
    return;
  }
  response->code = COAP_RESPONSE_CODE(201);
  coap_add_data_blocked_response(resource, session, request, response, token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 nr, req_buf);   
  return;
  coap_free(req_buf);
}


/*
 * POST handler - /oic/boot
 * exchanges shared secret with controller
 */
static void
ocf_hnd_post_boot(coap_context_t  *ctx UNUSED_PARAM,
             struct coap_resource_t *resource UNUSED_PARAM,
             coap_session_t *session,
             coap_pdu_t *request,
             coap_binary_t *token,
             coap_string_t *query UNUSED_PARAM,
             coap_pdu_t *response)
{
  uint8_t* data = NULL;
  size_t size = 0; 
  uint8_t  ok = 0;
  uint8_t  tag = 0;
  
	/* check whether data need to be returend */
  if (request) {
	coap_block_t block2 = { 0, 0, 0};
	if (coap_get_block(request, COAP_OPTION_BLOCK2, &block2)){	
      coap_add_data_blocked_response(resource, session, request, response, token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 SW_ret_data.length, SW_ret_data.s);
     return;
     } /* coap_get_block */
  } /* request */
	
  data = assemble_data( session, request, response, &size);
  if (data == (void *)-1)return;  /* more blocks to arrive */
  if ((data == NULL) | (size == 0)){
	  oscore_error_return(COAP_RESPONSE_CODE(400), 
      response, "Did not find request data\n");
	  return;
  }
  
    uint8_t  elem = cbor_get_next_element(&data);
    if (elem == CBOR_MAP){ 
      uint64_t map_size = cbor_get_element_size(&data);
      for (uint i=0 ; i < map_size; i++){
        tag = cose_get_tag(&data);
        switch (tag){
          case OAUTH_CLAIM_ACCESSTOKEN:
            if (ASSW_key_id != NULL) free(ASSW_key_id);
            cbor_get_string_array(&data, 
                           &ASSW_key_id, &ASSW_key_id_len);
            break;
          case OAUTH_CLAIM_KEYINFO:
            if (IP_AS != NULL) free(IP_AS);
            cbor_get_string_array(&data, 
                           &IP_AS, &IP_AS_len);
            break;
          default:
            ok = 1;
            break;
        } /* switch  */ 
        if(ok != 0){
          oscore_error_return(COAP_RESPONSE_CODE(400), 
          response, "Decode error in switch boot payload\n");
          return;
        } /* if ok */
      } /* for map_size  */
      if(SW_ret_data.s != NULL)coap_free(SW_ret_data.s);
      SW_return_bootkey(&SW_ret_data);
    } /* if elem */
    response->code = COAP_RESPONSE_CODE(201);  
    coap_add_data_blocked_response(resource, session, request, response, token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 SW_ret_data.length, SW_ret_data.s);   
    return; 
}


/*
 * POST handler - /oic/authz-info
 * receives CWT with authorization to manipulate switch
 * sets up the oscore context
 */
void
switch_hnd_post_authz(coap_context_t  *ctx UNUSED_PARAM,
             struct coap_resource_t *resource UNUSED_PARAM,
             coap_session_t *session,
             coap_pdu_t *request,
             coap_binary_t *in_token,
             coap_string_t *query UNUSED_PARAM,
             coap_pdu_t *response)
{
  oauth_cwtkey_t *key_enc = NULL;
  size_t size;
  uint8_t *data;
  oauth_token_t *token = NULL;
  uint8_t *cnonce = NULL;
  
 	/* check whether data need to be returend */
  if (request) {
	coap_block_t block2 = { 0, 0, 0};
	if (coap_get_block(request, COAP_OPTION_BLOCK2, &block2)){	
      coap_add_data_blocked_response(resource, session, request, response, in_token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 SW_ret_data.length, SW_ret_data.s);
     return;
     } /* coap_get_block */
  } /* request */
	 
  
/* one authorizations can be returned:
 * authorization to manipulate switch
 */
  data = assemble_data(session, request, response, &size);
  if (data == (void *)-1)return;  /* more blocks to arrive */
  if ((data == NULL) | (size == 0)){
	  oscore_error_return(COAP_RESPONSE_CODE(400), 
      response, "Did not find request data");
	  return;
  }
  
  if (oauth_strip(&data, &cnonce, &key_enc) == 1){
      oscore_error_return(COAP_RESPONSE_CODE(400), 
                      response, "Cannot extract CWT");
      return;
    } /* if oauth_strip  */

/*  keyenc->data points to PoP CWT
    nonce points to nonce */
  uint8_t aad_buffer[35];
  char ocf_switch[] = "oic_onoff";
  uint8_t *enc_token = key_enc->data;
  uint8_t elem = cbor_get_next_element(&enc_token);
  if (elem != CBOR_TAG){
	if (cnonce != NULL) free(cnonce);
	if(key_enc != NULL) oauth_delete_cwt_key(key_enc);
    oscore_error_return(COAP_RESPONSE_CODE(400), 
            response, "No CWT tag found");
    return;
  }
  size_t aad_len = switch_prepare_aad(
                   COSE_Algorithm_AES_CCM_16_64_128, aad_buffer);
  token = oauth_decrypt_token(&enc_token, ASSW_KEY, aad_buffer, aad_len);
  if (token == NULL){
	if (cnonce != NULL) free(cnonce);
	if(key_enc != NULL) oauth_delete_cwt_key(key_enc);
	oscore_error_return(COAP_RESPONSE_CODE(400), 
            response, "impossible to decrypt token");
    return;
  }
  size_t scope_len;
  uint8_t *scope = NULL;
  switch_get_scope(token->scope, &scope, &scope_len);
  if ((strncmp((char *)scope, ocf_switch, scope_len) == 0)
       && (scope_len == strlen(ocf_switch))){
/* authorization for switch manipulation */
/* create rsnonce  for return */
    rsnonce = coap_malloc(8);
    uint32_t nonce1 = (uint32_t)rand();
    uint32_t nonce2 = (uint32_t)rand();
    for (int qq =0 ; qq < 4; qq ++){
      rsnonce[qq] = ((nonce1 >> (qq*8)) & 0xFF);
      rsnonce[qq + 4] = ((nonce2 >> (qq*8)) & 0xFF);
    } /* for */
  } /* if ocf_switch */
  else{
	if (cnonce != NULL) free(cnonce);
	if(key_enc != NULL) oauth_delete_cwt_key(key_enc);
	oauth_delete_token(token);
    oscore_error_return(COAP_RESPONSE_CODE(400), 
                               response, "Illegal scope value");
    return;
  }
  
/* cnonce contains received 8-byte nonce      */
  oauth_cnf_t *pt= token->osc_sec_config;
  if (pt == NULL){
    oscore_error_return(COAP_RESPONSE_CODE(400), 
                               response, "configuration is missing");
    return;
  }
  uint8_t  *nonce = coap_malloc(24);
  uint32_t nonce1 = (uint32_t)rand();
  uint32_t nonce2 = (uint32_t)rand();
  for (int qq =0 ; qq < 4; qq ++){
     nonce[qq + 16] = ((nonce1 >> (qq*8)) & 0xFF);
     nonce[qq + 20] = ((nonce2 >> (qq*8)) & 0xFF);
     nonce[qq+8] = cnonce[qq];
     nonce[qq+12] = cnonce[qq+4];
     nonce[qq] = pt->salt[qq];
     nonce[qq+4] = pt->salt[qq+4];
  }
  /* do not free nonce, because used in oscore context */
  if (cnonce != NULL) free(cnonce);
  if(key_enc != NULL) oauth_delete_cwt_key(key_enc);
  switch_create_context(token, nonce);
  oauth_delete_token(token);
  if(SW_ret_data.s != NULL)coap_free(SW_ret_data.s);
  SW_return_nonce(&SW_ret_data, nonce+16);
  response->code = COAP_RESPONSE_CODE(201);
  coap_add_data_blocked_response(resource, session, request, response, in_token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 SW_ret_data.length, SW_ret_data.s);   
  return;
}

/*
 * switch_return_value
 * returns value 
 */
static void
switch_return_value(coap_string_t *response, uint8_t cbor_bool)
{
  char value[] = "value";
  int nr =0;
  uint8_t req_buf[20];
  uint8_t *buf = req_buf;
  nr += cbor_put_map(&buf, 1);
  nr += cbor_put_text(&buf, value, 5);
  nr += cbor_put_simple_value(&buf, cbor_bool);
  response->length = nr;
  response->s = coap_malloc(nr);
  memcpy(response->s,req_buf, nr);
  return;
}


/*
 * get handler - /oic/onoff
 * receives request to read switch status
 */
void
ocf_hnd_get_switch(coap_context_t  *ctx UNUSED_PARAM,
             struct coap_resource_t *resource,
             coap_session_t *session,
             coap_pdu_t *request,
             coap_binary_t *token,
             coap_string_t *query,
             coap_pdu_t *response)
{
		/* check whether data need to be returned */
  if (request) {
	coap_block_t block2 = { 0, 0, 0};
	if (coap_get_block(request, COAP_OPTION_BLOCK2, &block2)){	
	  if (block2.num > 0){
          coap_add_data_blocked_response(resource, session, request, response, token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 SW_ret_data.length, SW_ret_data.s);
          return;
       } /* block2.num */
     } /* coap_get_block */
  } /* request */
  if (!session->oscore_encryption){
	 if(SW_ret_data.s != NULL)coap_free(SW_ret_data.s);
	 fprintf(stderr,"invoke SW_return_AS \n");
     SW_return_AS(&SW_ret_data);
     response->code = COAP_RESPONSE_CODE(401);
     coap_add_data_blocked_response(resource, session, request, response, token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 SW_ret_data.length, SW_ret_data.s);
     return;
   }
   if ( query == NULL){
	  oscore_error_return(COAP_RESPONSE_CODE(400), 
      response, "No query present");
	  return;
	}
	if ((strncmp("if=oic.if.a", (char *)query->s, query->length) != 0)
	    || (query->length != 11)){
      oscore_error_return(COAP_RESPONSE_CODE(400), 
      response, "illegal if specification");
	  return;
	}
    if(SW_ret_data.s != NULL)coap_free(SW_ret_data.s);
    uint8_t cbor_value = 0;
    if (switch_value == 0) cbor_value = CBOR_FALSE;
    else cbor_value = CBOR_TRUE;
    switch_return_value(&SW_ret_data, cbor_value);
    response->code = COAP_RESPONSE_CODE(201);
    coap_add_data_blocked_response(resource, session, request, response, token,
                                 COAP_MEDIATYPE_APPLICATION_ACE_CBOR, -1,
                                 SW_ret_data.length, SW_ret_data.s);   
    return;

}

/*
 * init resource for switch
 */

void
switch_init_resources(coap_context_t *ctx) {
	
/* initialize list of endpoints of this ocf device */
  struct ifaddrs *ifaddr, *ifa;
  int family, s;
  if (getifaddrs(&ifaddr) != -1) {
	 char host[NI_MAXHOST];
     ifa = ifaddr;
     while (ifa){
		 if (ifa->ifa_addr){
			family = ifa->ifa_addr->sa_family;
			s = getnameinfo(ifa->ifa_addr,
                 (family == AF_INET) ? sizeof(struct sockaddr_in) :
                                      sizeof(struct sockaddr_in6),
                     host, NI_MAXHOST,
                     NULL, 0, NI_NUMERICHOST);
            if (s == 0 && strlen(host) > 3){
			  uint8_t lan_att = 0;
			  for (uint8_t k = 0; k < strlen(host); k++) {
				  char ch = host[k];
				  if (ch == '%') lan_att = 1;
			  }
			  if (lan_att == 0){
				char prefix[] = "coap://[";
				uint8_t pre_len = strlen(prefix);
				uint8_t ep_len = strlen(prefix) + strlen(host) +1;
			    struct ocf_ep_t *ep = malloc(sizeof(struct ocf_ep_t));
			    ep->ep.length = ep_len;
			    ep->ep.s = coap_malloc(ep_len + 1);
			    memcpy(ep->ep.s, prefix, pre_len);
			    memcpy(ep->ep.s + pre_len, host, strlen(host));
			    ep->ep.s[ep_len-1] = ']';
			    ep->ep.s[ep_len] = 0;
			    char wlan0[] = "wlan0";
				if (strcmp(wlan0, ifa->ifa_name)  == 0){
			      IP_SW.s = malloc(ep_len+1);
			      IP_SW.length = ep_len;
			      memcpy(IP_SW.s, ep->ep.s, ep->ep.length);
			    }
		        ep->next = ocf_eps;
		        ocf_eps = ep;
		        ocf_ep_nr++;
		      }  /* lan_att */
	        }  /* s==0 */
		  } /* ifa->if_addr */
          ifa = ifa->ifa_next;
	 } /* while */        
  } /* getifaddrs  */
  freeifaddrs( ifaddr);
  
  char uu_pre[] = "uu_SW";
  SW_identifier.length = 11;
  SW_identifier.s = coap_malloc(SW_identifier.length);
  memcpy(SW_identifier.s, uu_pre, 5);
  cr_namenr(SW_identifier.s + 5);
  
  
/* initialize the resource paths */
  coap_resource_t *  r = coap_resource_init(NULL, 0);
  
r = coap_resource_init(coap_make_str_const("oic/authz-info"), resource_flags);
  coap_register_handler(r, COAP_REQUEST_POST, switch_hnd_post_authz);
  coap_add_attr(r, coap_make_str_const("ct"), coap_make_str_const("60"), 0);
  coap_add_attr(r, coap_make_str_const("title"), coap_make_str_const("\"Authorize switch access\""), 0);
  coap_add_attr(r, coap_make_str_const("rt"), coap_make_str_const("\"oic.d.switch\""), 0);
  coap_add_attr(r, coap_make_str_const("if"), coap_make_str_const("\"ocf switch device\""), 0);

  coap_add_resource(ctx, r);
  
r = coap_resource_init(coap_make_str_const("oic/boot"), resource_flags);
  coap_register_handler(r, COAP_REQUEST_POST, ocf_hnd_post_boot); 
  coap_add_attr(r, coap_make_str_const("ct"), coap_make_str_const("60"), 0);
  coap_add_attr(r, coap_make_str_const("title"), coap_make_str_const("\"boot switch\""), 0);
  coap_add_attr(r, coap_make_str_const("rt"), coap_make_str_const("\"oic.d.switch\""), 0);
  coap_add_attr(r, coap_make_str_const("if"), coap_make_str_const("\"ocf boot device\""), 0);

  coap_add_resource(ctx, r);
  
r = coap_resource_init(coap_make_str_const("oic/onoff"), resource_flags);
  coap_register_handler(r, COAP_REQUEST_GET, ocf_hnd_get_switch);
   coap_register_handler(r, COAP_REQUEST_POST, ocf_hnd_post_switch); 
  coap_add_attr(r, coap_make_str_const("ct"), coap_make_str_const("60"), 0);
  coap_add_attr(r, coap_make_str_const("title"), coap_make_str_const("\"access switch\""), 0);
  coap_add_attr(r, coap_make_str_const("rt"), coap_make_str_const("\"oic.r.switch.binary\""), 0);
  coap_add_attr(r, coap_make_str_const("if"), coap_make_str_const("\"ocf switch device\""), 0);

  coap_add_resource(ctx, r);
 
 /* standard ocf resources */ 
  
  r = coap_resource_init(coap_make_str_const("oic/d"), resource_flags);
  coap_register_handler(r, COAP_REQUEST_GET, ocf_hnd_wk_d); 
  coap_add_attr(r, coap_make_str_const("ct"), coap_make_str_const("60"), 0);
  coap_add_attr(r, coap_make_str_const("title"), coap_make_str_const("\"ocf device\""), 0);
  coap_add_attr(r, coap_make_str_const("rt"), coap_make_str_const("\"oic.wk.d\""), 0);
  coap_add_attr(r, coap_make_str_const("if"), coap_make_str_const("\"oic.if.baseline\""), 0);

  coap_add_resource(ctx, r);
  
    r = coap_resource_init(coap_make_str_const("oic/p"), resource_flags);
  coap_register_handler(r, COAP_REQUEST_GET, ocf_hnd_wk_p); 
  coap_add_attr(r, coap_make_str_const("ct"), coap_make_str_const("60"), 0);
  coap_add_attr(r, coap_make_str_const("title"), coap_make_str_const("\"ocf platform\""), 0);
  coap_add_attr(r, coap_make_str_const("rt"), coap_make_str_const("\"oic.wk.p\""), 0);
  coap_add_attr(r, coap_make_str_const("if"), coap_make_str_const("\"oic.if.baseline\""), 0);

  coap_add_resource(ctx, r);
  
  r = coap_resource_init(coap_make_str_const("oic/res"), resource_flags);
  coap_register_handler(r, COAP_REQUEST_GET, ocf_hnd_wk_res); 
  coap_add_attr(r, coap_make_str_const("ct"), coap_make_str_const("60"), 0);
  coap_add_attr(r, coap_make_str_const("title"), coap_make_str_const("\"ocf resources\""), 0);
  coap_add_attr(r, coap_make_str_const("rt"), coap_make_str_const("\"oic.wk.res\""), 0);
  coap_add_attr(r, coap_make_str_const("if"), coap_make_str_const("\"oic.if.baseline\""), 0);

  coap_add_resource(ctx, r);
}


